
## 🌱 Maven 的生命周期（顺序逻辑）

Maven 的构建过程是**一套固定的顺序**，叫做**生命周期**，主要这几个阶段：

```
compile → test → package → verify → install → deploy
```

它们是**一层套一层**的关系，**!后面的会自动执行前面的**。 
比如test就会自动执行compile


---

### 🔥 各个阶段一看就懂的解释：

| 阶段        | 作用                                  | 类比          |
| --------- | ----------------------------------- | ----------- |
| `compile` | **编译**源码 `.java` ➔ `.class`         | 把生肉切好（准备下锅） |
| `test`    | **运行单元测试**（一般测试代码在 `src/test/java`） | 试吃，检测有没有毒   |
| `package` | **打包**成 `.jar` 或 `.war`             | 装盒，准备外卖     |
| `verify`  | **验证**打包后的一些质量检查                    | 检查外卖包装是否密封好 |
| `install` | **安装**到本地 Maven 仓库                  | 把外卖放进自己家的冰箱 |
| `deploy`  | **部署**到远程仓库给别人用                     | 把外卖送到客户手上   |

---

## ✅ 它们的**顺序**

Maven 是**一步步来的**：

* 如果你执行 `mvn package`，它会自动先做：

  ```
  compile → test → package
  ```

* 如果你执行 `mvn verify`，它会自动先做：

  ```
  compile → test → package → verify
  ```

### 🚩 重点记住：

> **每个阶段自动包含前面所有阶段**
> 比如 `package` 其实= `compile` + `test` + `package`

---

## ⚙️ **原理：为什么要这样做**

1. **流程标准化**：

    * 让每个人的构建顺序**统一**，不会乱七八糟（先测试还是先打包？Maven帮你定好了）

2. **自动化**：

    * 你只要说一句 `mvn package`，Maven帮你**一条龙**搞定编译、测试、打包。

3. **模块化**：

    * 如果你只是想**编译**不想打包？执行 `mvn compile` 就行。
    * 想完整流程？执行 `mvn package`。

---

## 📚 小总结表

| 命令            | 自动顺序执行了什么                       |
| ------------- | ------------------------------- |
| `mvn compile` | 只编译源代码                          |
| `mvn test`    | 编译 + 测试                         |
| `mvn package` | 编译 + 测试 + 打包                    |
| `mvn verify`  | 编译 + 测试 + 打包 + 验证               |
| `mvn install` | 编译 + 测试 + 打包 + 验证 + 安装到本地仓库     |
| `mvn deploy`  | 编译 + 测试 + 打包 + 验证 + 安装 + 部署远程仓库 |

---

## 🎯 为什么要按这个顺序？

逻辑就像流水线：

1. **没编译（compile）** ➔ 你不能测试（test）
2. **没测试（test）** ➔ 不敢打包（package）
3. **没打包（package）** ➔ 验证（verify）和安装（install）就没有意义

---

### 🚀 一句话总结：

> Maven 就像个**自动工厂流水线**，`compile` ➔ `test` ➔ `package` ➔ `verify`，一步步走，保证成品**标准、安全、可用**。

---

要不要我顺手也帮你画个「Maven生命周期流程图」？一图就彻底记住了。
